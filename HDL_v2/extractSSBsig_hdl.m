function [dataOut_re, dataOut_im, validOut, ssbNumsOut, ssbNumsValidOut] = extractSSBsig_hdl(dataIn_re, dataIn_im, peakValid, peakIdx, validIn)
% HDL-compatible streaming implementation of extractSSBsig function
% This function extracts SSB signals from received signals in a streaming manner
% suitable for HDL Coder synthesis.
%
% Inputs:
%   dataIn_re      - Real part of received signal sample (Q1.15 fixed-point)
%   dataIn_im      - Imaginary part of received signal sample (Q1.15 fixed-point)
%   peakValid      - Valid flag for peak location (boolean)
%   peakIdx        - Peak location timestamp (uint16, 0-based)
%   validIn        - Valid flag for input data (boolean)
%
% Outputs:
%   dataOut_re     - Real part of extracted SSB sample (Q1.15 fixed-point)
%   dataOut_im     - Imaginary part of extracted SSB sample (Q1.15 fixed-point)
%   validOut       - Valid flag for output data (boolean)
%   ssbNumsOut     - Number of SSB symbols extracted (uint16)
%   ssbNumsValidOut- Valid flag for ssbNumsOut (boolean)
%
% Author: Generated by HDL Coder
% Date: 06/01/2025
%--------------------------------------------------------------------------

%#codegen

% Constants
% NFFT = uint16(256);
% CP_LENGTH = uint16(18);
% OFDM_SYMBOL_LENGTH = uint16(274); % NFFT + CP_LENGTH
% SSB_SYMBOL_COUNT = uint16(4);
SSB_LENGTH = uint16(1096); % 4 * 274
PSS_OFFSET = uint16(273); % NFFT + CP_LENGTH - 1

% Buffer sizes (power of 2)
BUFFER_BIT = uint16(11); % 2^11 = 2048 > SSB_LENGTH (1096) - Note: needs multiple turns
RX_BUFFER_SIZE = uint16(2^BUFFER_BIT); % 2048
FIFO_BIT = uint16(4); % 2^4 = 16
PEAK_FIFO_SIZE = uint16(2^FIFO_BIT); % 16
% OUTPUT_BUFFER_SIZE = uint16(2048);

% Buffer masks for efficient addressing
RX_BUFFER_MASK = uint16(RX_BUFFER_SIZE - 1); % RX_BUFFER_SIZE - 1
PEAK_FIFO_MASK = uint16(PEAK_FIFO_SIZE - 1);   % PEAK_FIFO_SIZE - 1
% OUTPUT_BUFFER_MASK = uint16(2047); % OUTPUT_BUFFER_SIZE - 1

% State machine states
IDLE = uint8(0);
CHECK_EVENT = uint8(1);
WAITING_FOR_DATA = uint8(2);
PROCESSING_DATA = uint8(3);

% Data types
dataType = numerictype(1, 16, 15); % Q1.15 fixed-point

% Persistent variables (state memory)
persistent state
persistent sampleCounter
persistent rxBuffer_re rxBuffer_im
persistent rxWritePtr rxReadPtr
persistent peakFifo peakFifoWritePtr peakFifoReadPtr peakFifoCount
% persistent outputBuffer_re outputBuffer_im
% persistent outputWritePtr outputReadPtr outputCount
persistent extractStartIdx extractEndIdx extractSampleCount
persistent ssbCount
persistent processingPeakIdx

% Initialize persistent variables on first call
if isempty(state)
    % State machine initialization
    state = IDLE;
    sampleCounter = uint16(0);
    
    % Initialize buffers with proper fixed-point types
    rxBuffer_re = fi(zeros(RX_BUFFER_SIZE, 1), dataType);
    rxBuffer_im = fi(zeros(RX_BUFFER_SIZE, 1), dataType);
    rxWritePtr = uint16(1);  % 1-based indexing
    rxReadPtr = uint16(1);   % 1-based indexing
    
    % Peak FIFO initialization
    peakFifo = zeros(PEAK_FIFO_SIZE, 1, 'uint16');
    peakFifoWritePtr = uint16(1); % 1-based indexing
    peakFifoReadPtr = uint16(1); % 1-based indexing
    peakFifoCount = uint16(0);
    
    % % Output buffer initialization
    % outputBuffer_re = fi(zeros(OUTPUT_BUFFER_SIZE, 1), dataType);
    % outputBuffer_im = fi(zeros(OUTPUT_BUFFER_SIZE, 1), dataType);
    % outputWritePtr = uint16(0);
    % outputReadPtr = uint16(0);
    % outputCount = uint16(0);
    
    % Processing variables
    extractStartIdx = uint16(0);
    extractEndIdx = uint16(0);
    extractSampleCount = uint16(0);
    ssbCount = uint16(0);
    processingPeakIdx = uint16(0);
end

% Initialize outputs
dataOut_re = fi(0, dataType);
dataOut_im = fi(0, dataType);
validOut = false;
ssbNumsOut = uint16(0);
ssbNumsValidOut = false;

% Buffer incoming data when valid
if validIn
    % Store received sample in circular buffer (1-based indexing)
    rxBuffer_re(rxWritePtr) = dataIn_re;
    rxBuffer_im(rxWritePtr) = dataIn_im;
    
    % Update write pointer with wrap-around
    if rxWritePtr >= RX_BUFFER_SIZE
        rxWritePtr = uint16(1);
    else
        rxWritePtr = rxWritePtr + uint16(1);
    end
    
    % Increment sample counter
    sampleCounter = sampleCounter + uint16(1);
end

% Buffer incoming peak events
if peakValid
    % Store peak in FIFO if not full
    if peakFifoCount < PEAK_FIFO_SIZE
        peakFifo(peakFifoWritePtr) = peakIdx;
        
        % Update FIFO write pointer with wrap-around
        if peakFifoWritePtr >= PEAK_FIFO_SIZE
            peakFifoWritePtr = uint16(1);
        else
            peakFifoWritePtr = peakFifoWritePtr + uint16(1);
        end
        
        peakFifoCount = peakFifoCount + uint16(1);
        
        % Debug output - will be removed in final version
        %fprintf('DEBUG: Stored peak %d in FIFO, count now %d\n', peakIdx, peakFifoCount);
    end
end

% State machine processing
switch state
    case IDLE
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Transition to check for events
        % Check if there are any peak events to process
        if peakFifoCount > uint16(0)
            state = CHECK_EVENT;
        end

    case CHECK_EVENT
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Read peak from FIFO
        processingPeakIdx = peakFifo(peakFifoReadPtr);
        
        % Update FIFO read pointer with wrap-around
        if peakFifoReadPtr >= PEAK_FIFO_SIZE
            peakFifoReadPtr = uint16(1);
        else
            peakFifoReadPtr = peakFifoReadPtr + uint16(1);
        end
        
        peakFifoCount = peakFifoCount - uint16(1);
        
        % Calculate extraction indices (convert to 0-based)
        % extractStartIdx = (peakIdx) - PSS_OFFSET
        % if processingPeakIdx >= PSS_OFFSET
        %     extractStartIdx = processingPeakIdx - PSS_OFFSET;
        % else
        %     extractStartIdx = uint16(0); % Invalid case, will be handled
        % end
        % Calculate oldest sample needed directly (like reference design)
        extractStartIdx = processingPeakIdx - uint16(PSS_OFFSET);
        
        extractEndIdx = extractStartIdx + SSB_LENGTH;
        extractSampleCount = uint16(0);
        % Check if data is stale (already overwritten in buffer)
        if sampleCounter >= RX_BUFFER_SIZE + extractStartIdx
            state = IDLE;
        else
            state = WAITING_FOR_DATA;
        end
        
    case WAITING_FOR_DATA
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Check if enough data is available in the buffer
        % We need data up to extractEndIdx-1 (since extractEndIdx is exclusive)
        % Data is available if sampleCounter > extractEndIdx-1
        if sampleCounter >= extractEndIdx
            state = PROCESSING_DATA;
            bufferStartIdx = bitand(extractStartIdx, RX_BUFFER_MASK); 
            rxReadPtr = bufferStartIdx + uint16(1); % Set read pointer to start of extraction (1-based)
        else
            % Not enough data available, stay in WAITING_FOR_DATA
            state = WAITING_FOR_DATA;
        end
        
    case PROCESSING_DATA
        % Initialize all outputs for this state
        ssbNumsValidOut = false;
        
        % Check if we have more samples to extract
        if extractSampleCount < SSB_LENGTH
            % Read sample from buffer at current position
            sampleRe = rxBuffer_re(rxReadPtr);
            sampleIm = rxBuffer_im(rxReadPtr);

            % Output the sample
            dataOut_re = sampleRe;
            dataOut_im = sampleIm;
            validOut = true;
            
            % Increment sample count
            extractSampleCount = extractSampleCount + uint16(1);
            
            % Update buffer read pointer with wrap-around (after reading)
            if rxReadPtr >= RX_BUFFER_SIZE
                rxReadPtr = uint16(1);
            else
                rxReadPtr = rxReadPtr + uint16(1);
            end
            
            % Stay in PROCESSING_DATA state
            state = PROCESSING_DATA;
        else
            % Finished extracting this SSB symbol
            validOut = false;
            ssbCount = ssbCount + uint16(1);
            
            % Output SSB count
            ssbNumsOut = ssbCount;
            ssbNumsValidOut = true;

            % Return to IDLE state to check for more events
            state = IDLE;
        end
        
    otherwise
        % Invalid state, return to IDLE
        validOut = false;
        ssbNumsValidOut = false;
        state = IDLE;
end

end
