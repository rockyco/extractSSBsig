% HDL-compatible testbench for extractSSBsig_hdl function
% This testbench validates the HDL implementation against the reference data
% using streaming input/output interface suitable for HDL Coder.
%
% Author: Generated by HDL Coder
% Date: 06/01/2025
%--------------------------------------------------------------------------

fprintf('Starting HDL extractSSBsig test\n');

% Clear any persistent variables from previous runs
clear extractSSBsig_hdl;
clear extractSSBsig_hdl_debug;

%% Load input data
fprintf('Loading correlatorIn.mat\n');
data = load('correlatorIn.mat');
rxSig = data.correlatorIn;
fprintf('Size of rxSig: %dx%d\n', size(rxSig, 1), size(rxSig, 2));

fprintf('Loading selectedPeak.mat\n');
data = load('selectedPeak.mat');
selectedPeak = data.selectedPeak;
fprintf('Size of selectedPeak: %dx%d\n', size(selectedPeak, 1), size(selectedPeak, 2));
fprintf('Contents of selectedPeak: %s\n', mat2str(selectedPeak));

%% Load reference outputs
fprintf('Loading reference data\n');
data = load('ssbSig.mat');
ssbSig_ref = data.ssbSig;
fprintf('Size of ssbSig_ref: %dx%d\n', size(ssbSig_ref, 1), size(ssbSig_ref, 2));

data = load('ssbNums.mat');
ssbNums_ref = data.ssbNums;
fprintf('ssbNums_ref: %d\n', ssbNums_ref);

%% Prepare data types for HDL function
dataType = numerictype(1, 16, 15); % Q1.15 fixed-point

% Convert input signal to fixed-point
rxSig_fi_re = fi(real(rxSig), dataType);
rxSig_fi_im = fi(imag(rxSig), dataType);

% Convert selectedPeak to 0-based indexing (HDL convention)
selectedPeak_0based = selectedPeak - 1;

% Convert to uint16
selectedPeak_uint16 = uint16(selectedPeak_0based);

%% Prepare streaming simulation
numSamples = length(rxSig);
numPeaks = length(selectedPeak);

% Output collection arrays
ssbSig_hdl = [];
ssbNums_hdl = 0;

% Peak event timing - inject peaks shortly after their actual locations
% to simulate realistic detection latency
peakEventTimes = zeros(numPeaks, 1);
if numPeaks > 0
    for i = 1:numPeaks
        % Inject peak event 100 samples after the actual peak location
        % to simulate detection latency
        peakEventTimes(i) = selectedPeak(i) + 100;
    end
end

peakEventIndex = 1;

fprintf('Starting streaming simulation with %d samples\n', numSamples);

%% Streaming simulation loop
for sampleIdx = 1:numSamples
    % Prepare inputs for current sample
    dataIn_re = rxSig_fi_re(sampleIdx);
    dataIn_im = rxSig_fi_im(sampleIdx);
    validIn = true;
    
    % Check if we should inject a peak event at this time
    peakValid = false;
    peakIdx = uint16(0);
    
    if peakEventIndex <= numPeaks && sampleIdx == peakEventTimes(peakEventIndex)
        peakValid = true;
        peakIdx = selectedPeak_uint16(peakEventIndex);
        fprintf('Injecting peak event %d at sample %d: peak location = %d (1-based: %d)\n', ...
            peakEventIndex, sampleIdx, peakIdx, selectedPeak(peakEventIndex));
        peakEventIndex = peakEventIndex + 1;
    end
    
    % Call HDL function
    [dataOut_re, dataOut_im, validOut, ssbNumsOut, ssbNumsValidOut] = ...
        extractSSBsig_hdl(dataIn_re, dataIn_im, peakValid, peakIdx, validIn);
    
    % Collect valid outputs
    if validOut
        % Convert back to complex double for comparison
        sampleOut = double(dataOut_re) + 1i * double(dataOut_im);
        ssbSig_hdl = [ssbSig_hdl; sampleOut];
    end
    
    % Collect SSB count when valid
    if ssbNumsValidOut
        ssbNums_hdl = double(ssbNumsOut);
        fprintf('SSB count updated: %d\n', ssbNums_hdl);
    end
    
    % Progress indication
    if mod(sampleIdx, 1000) == 0
        fprintf('Processed %d/%d samples\n', sampleIdx, numSamples);
    end
end

% Run additional cycles to flush any remaining data
fprintf('Flushing remaining data...\n');
for flushIdx = 1:1500  % Increased flush cycles
    [dataOut_re, dataOut_im, validOut, ssbNumsOut, ssbNumsValidOut] = ...
        extractSSBsig_hdl(fi(0, dataType), fi(0, dataType), false, uint16(0), false);
    
    if validOut
        sampleOut = double(dataOut_re) + 1i * double(dataOut_im);
        ssbSig_hdl = [ssbSig_hdl; sampleOut];
    end
    
    if ssbNumsValidOut
        ssbNums_hdl = double(ssbNumsOut);
    end
end

fprintf('HDL simulation completed\n');
fprintf('HDL output size: %dx%d\n', size(ssbSig_hdl, 1), size(ssbSig_hdl, 2));
fprintf('HDL ssbNums: %d\n', ssbNums_hdl);

%% Compare results
testPassed = true;
tolerance = 1e-3; % Tolerance for fixed-point comparison

% Check SSB count
if ssbNums_hdl ~= ssbNums_ref
    fprintf('ERROR: ssbNums mismatch - HDL: %d, Reference: %d\n', ssbNums_hdl, ssbNums_ref);
    testPassed = false;
else
    fprintf('PASS: ssbNums match - %d\n', ssbNums_hdl);
end

% Check output signal size
if size(ssbSig_hdl, 1) ~= size(ssbSig_ref, 1)
    fprintf('ERROR: Output size mismatch - HDL: %dx%d, Reference: %dx%d\n', ...
        size(ssbSig_hdl, 1), size(ssbSig_hdl, 2), size(ssbSig_ref, 1), size(ssbSig_ref, 2));
    testPassed = false;
else
    fprintf('PASS: Output sizes match - %dx%d\n', size(ssbSig_hdl, 1), size(ssbSig_hdl, 2));
end

% Check signal values with tolerance
if size(ssbSig_hdl, 1) == size(ssbSig_ref, 1)
    errorVec = abs(ssbSig_hdl - ssbSig_ref);
    maxError = max(errorVec);
    meanError = mean(errorVec);
    
    fprintf('Signal comparison:\n');
    fprintf('  Max error: %g\n', maxError);
    fprintf('  Mean error: %g\n', meanError);
    fprintf('  Tolerance: %g\n', tolerance);
    
    if maxError <= tolerance
        fprintf('PASS: Signal values within tolerance\n');
    else
        fprintf('ERROR: Signal values exceed tolerance\n');
        testPassed = false;
        
        % Find worst error locations
        [~, worstIdx] = max(errorVec);
        fprintf('  Worst error at index %d: HDL=%g%+gi, Ref=%g%+gi, Error=%g\n', ...
            worstIdx, real(ssbSig_hdl(worstIdx)), imag(ssbSig_hdl(worstIdx)), ...
            real(ssbSig_ref(worstIdx)), imag(ssbSig_ref(worstIdx)), errorVec(worstIdx));
    end
end

%% Save results for debugging
fprintf('Saving HDL test results...\n');
save('hdl_test_results.mat', 'ssbSig_hdl', 'ssbNums_hdl', 'ssbSig_ref', 'ssbNums_ref');

% Write output files for verification
writematrix([real(ssbSig_hdl), imag(ssbSig_hdl)], 'ssbSig_hdl.txt', 'Delimiter', 'tab');
writematrix(ssbNums_hdl, 'ssbNums_hdl.txt', 'Delimiter', 'tab');

%% Final result
if testPassed
    fprintf('\n=== HDL TEST PASSED ===\n');
else
    fprintf('\n=== HDL TEST FAILED ===\n');
    error('HDL testbench validation failed');
end

fprintf('HDL testbench completed successfully!\n');
