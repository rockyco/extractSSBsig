function [dataOut_re, dataOut_im, validOut, ssbNumsOut, ssbNumsValidOut] = extractSSBsig_hdl(dataIn_re, dataIn_im, peakValid, peakIdx, validIn)
% HDL-compatible streaming implementation of extractSSBsig function
% This function extracts SSB signals from received signals in a streaming manner
% suitable for HDL Coder synthesis.
%
% Inputs:
%   dataIn_re      - Real part of received signal sample (Q1.15 fixed-point)
%   dataIn_im      - Imaginary part of received signal sample (Q1.15 fixed-point)
%   peakValid      - Valid flag for peak location (boolean)
%   peakIdx        - Peak location timestamp (uint16, 0-based)
%   validIn        - Valid flag for input data (boolean)
%
% Outputs:
%   dataOut_re     - Real part of extracted SSB sample (Q1.15 fixed-point)
%   dataOut_im     - Imaginary part of extracted SSB sample (Q1.15 fixed-point)
%   validOut       - Valid flag for output data (boolean)
%   ssbNumsOut     - Number of SSB symbols extracted (uint16)
%   ssbNumsValidOut- Valid flag for ssbNumsOut (boolean)
%
% Author: Generated by HDL Coder
% Date: 06/01/2025
%--------------------------------------------------------------------------

%#codegen

% Define constants directly (not as persistent)
NFFT = uint16(256);  % FFT size
CP_LEN = uint16(18); % Cyclic prefix length
SYMBOL_LEN = uint16(NFFT + CP_LEN); % OFDM symbol length
NUM_SYMBOLS = uint16(4); % Number of OFDM symbols in SSB
SSB_LENGTH = uint16(NUM_SYMBOLS * SYMBOL_LEN); % Total SSB length

% Define buffer size as power of 2 (greater than SSB length)
BUFFER_BIT = uint16(9);  % 2^9 = 512 > SSB_LENGTH (1096) - Note: needs multiple turns
BUFFER_SIZE = uint16(2^BUFFER_BIT);
BUFFER_MASK = uint16(BUFFER_SIZE - 1);

% Define event FIFO size
EVENT_FIFO_BIT = uint16(1);  % 2^1 = 2
EVENT_FIFO_SIZE = uint16(2^EVENT_FIFO_BIT);

% Define states for FSM
IDLE = uint8(0);
CHECK_EVENT = uint8(1);
WAITING_FOR_DATA = uint8(2);
PROCESSING_DATA = uint8(3);

% Fixed-point type definitions for signal data only
rxSigType = numerictype(true, 16, 15);
ssbSigType = numerictype(true, 16, 15);

% Persistent variables - each declared individually for better HDL mapping
persistent state;
if isempty(state)
    state = IDLE;
end
persistent sampleCounter;
if isempty(sampleCounter)
    sampleCounter = uint16(0);
end
persistent bufferWritePtr;
if isempty(bufferWritePtr)
    bufferWritePtr = uint16(1);
end
persistent bufferReadPtr;
if isempty(bufferReadPtr)
    bufferReadPtr = uint16(1);
end
persistent eventFifoWritePtr;
if isempty(eventFifoWritePtr)
    eventFifoWritePtr = uint16(1);
end
persistent eventFifoReadPtr;
if isempty(eventFifoReadPtr)
    eventFifoReadPtr = uint16(1);
end
persistent eventFifoCount;
if isempty(eventFifoCount)
    eventFifoCount = uint16(0);
end
persistent extractStartIdx;
if isempty(extractStartIdx)
    extractStartIdx = uint16(0);
end
persistent extractEndIdx;
if isempty(extractEndIdx)
    extractEndIdx = uint16(0);
end
persistent extractSampleCount;
if isempty(extractSampleCount)
    extractSampleCount = uint16(0);
end
persistent ssbCount;
if isempty(ssbCount)
    ssbCount = uint16(0);
end
persistent processingPeakIdx;
if isempty(processingPeakIdx)
    processingPeakIdx = uint16(0);
end

% Initialize buffers
persistent rxBuffer_re rxBuffer_im eventFifo;
if isempty(rxBuffer_re)
    % Preallocate fixed-size buffers
    rxBuffer_re = fi(zeros(BUFFER_SIZE,1), rxSigType);
    rxBuffer_im = fi(zeros(BUFFER_SIZE,1), rxSigType);
    eventFifo = zeros(EVENT_FIFO_SIZE,1,'uint16');
end

% Initialize outputs
dataOut_re = fi(0, ssbSigType);
dataOut_im = fi(0, ssbSigType);
validOut = false;
ssbNumsOut = uint16(0);
ssbNumsValidOut = false;

% Step 1: Handle input data - store in circular buffer if valid
if validIn
    % Store sample in buffer
    rxBuffer_re(bufferWritePtr) = fi(dataIn_re, rxSigType);
    rxBuffer_im(bufferWritePtr) = fi(dataIn_im, rxSigType);
    
    % Check if we've wrapped around the buffer
    if bufferWritePtr >= BUFFER_SIZE
        % Buffer is full, wrap around
        bufferWritePtr = uint16(1);
    else
        % Buffer is not full, just increment
        bufferWritePtr = bufferWritePtr + uint16(1);
    end
    
    % Increment global sample counter
    sampleCounter = sampleCounter + uint16(1);
end

% Step 2: Handle peak event - store in event FIFO if valid
if peakValid
    % Check if FIFO has space
    if eventFifoCount < EVENT_FIFO_SIZE
        % Store peak location in FIFO
        eventFifo(eventFifoWritePtr) = peakIdx;
        
        % Check if we've wrapped around the FIFO
        if eventFifoWritePtr >= EVENT_FIFO_SIZE
            % FIFO is full, wrap around
            eventFifoWritePtr = uint16(1);
        else
            % FIFO is not full, just increment
            eventFifoWritePtr = eventFifoWritePtr + uint16(1);
        end
        
        % Increment count
        eventFifoCount = eventFifoCount + uint16(1);
    end
end

% State machine processing
switch state
    case IDLE
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Check if there are any peak events to process
        if eventFifoCount > uint16(0)
            % Transition to check for events
            state = CHECK_EVENT;
        else
            % No events to process, stay in IDLE
            state = IDLE;
        end

    case CHECK_EVENT
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Read peak from FIFO
        processingPeakIdx = eventFifo(eventFifoReadPtr);
        
        % Update FIFO read pointer with wrap-around
        if eventFifoReadPtr >= EVENT_FIFO_SIZE
            eventFifoReadPtr = uint16(1);
        else
            eventFifoReadPtr = eventFifoReadPtr + uint16(1);
        end
        
        eventFifoCount = eventFifoCount - uint16(1);
        
        % Calculate oldest sample needed directly (like reference design)
        extractStartIdx = processingPeakIdx - uint16(NFFT + CP_LEN - 1);
        
        % Check if data is stale (already overwritten in buffer)
        if sampleCounter >= BUFFER_SIZE + extractStartIdx
            % Data is stale, discard event and go back to IDLE
            state = IDLE;
        else
            state = WAITING_FOR_DATA;
        end
        
    case WAITING_FOR_DATA
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Check if SSB data is available in the buffer
        if sampleCounter >= extractStartIdx
            % SSB data available, transition to PROCESSING_DATA
            state = PROCESSING_DATA;
            extractSampleCount = uint16(0);
            % Calculate buffer start index like reference design
            bufferStartIdx = bitand(extractStartIdx, BUFFER_MASK);
            % Update buffer read pointer
            bufferReadPtr = bufferStartIdx + uint16(1);
        else
            % Not enough data available, stay in WAITING_FOR_DATA
            state = WAITING_FOR_DATA;
        end
        
    case PROCESSING_DATA
        % Initialize all outputs for this state
        ssbNumsValidOut = false;
        
        % Check if we have more samples to extract
        if extractSampleCount < SSB_LENGTH
            % Calculate current sample index
            currentOutputSample = extractStartIdx + extractSampleCount;
            
            % Check if this sample is valid (available in buffer)
            if currentOutputSample <= sampleCounter
                % Read sample from buffer
                sampleRe = rxBuffer_re(bufferReadPtr);
                sampleIm = rxBuffer_im(bufferReadPtr);

                % Output the sample
                dataOut_re = sampleRe;
                dataOut_im = sampleIm;
                validOut = true;
                
                % Increment sample count
                extractSampleCount = extractSampleCount + uint16(1);
                
                % Update buffer read pointer with wrap-around
                if bufferReadPtr >= BUFFER_SIZE
                    bufferReadPtr = uint16(1);
                else
                    bufferReadPtr = bufferReadPtr + uint16(1);
                end
            else
                % Sample not available yet, output invalid
                validOut = false;
            end
            
            % Stay in PROCESSING_DATA state
            state = PROCESSING_DATA;
        else
            % Finished extracting this SSB symbol
            validOut = false;
            ssbCount = ssbCount + uint16(1);
            
            % Output SSB count
            ssbNumsOut = ssbCount;
            ssbNumsValidOut = true;
            
            % Return to IDLE (like reference design)
            state = IDLE;
        end
        
    otherwise
        % Invalid state, return to IDLE
        validOut = false;
        ssbNumsValidOut = false;
        state = IDLE;
end

end
