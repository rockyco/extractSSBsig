function [dataOut_re, dataOut_im, validOut, ssbNumsOut, ssbNumsValidOut] = extractSSBsig_hdl(dataIn_re, dataIn_im, peakValid, peakIdx, validIn)
% HDL-compatible streaming implementation of extractSSBsig function
% This function extracts SSB signals from received signals in a streaming manner
% suitable for HDL Coder synthesis.
%
% Inputs:
%   dataIn_re      - Real part of received signal sample (Q1.15 fixed-point)
%   dataIn_im      - Imaginary part of received signal sample (Q1.15 fixed-point)
%   peakValid      - Valid flag for peak location (boolean)
%   peakIdx        - Peak location timestamp (uint16, 0-based)
%   validIn        - Valid flag for input data (boolean)
%
% Outputs:
%   dataOut_re     - Real part of extracted SSB sample (Q1.15 fixed-point)
%   dataOut_im     - Imaginary part of extracted SSB sample (Q1.15 fixed-point)
%   validOut       - Valid flag for output data (boolean)
%   ssbNumsOut     - Number of SSB symbols extracted (uint16)
%   ssbNumsValidOut- Valid flag for ssbNumsOut (boolean)
%
% Author: Generated by HDL Coder
% Date: 06/01/2025
%--------------------------------------------------------------------------

%#codegen

% Constants
% NFFT = uint16(256);
% CP_LENGTH = uint16(18);
% OFDM_SYMBOL_LENGTH = uint16(274); % NFFT + CP_LENGTH
% SSB_SYMBOL_COUNT = uint16(4);
SSB_LENGTH = uint16(1096); % 4 * 274
PSS_OFFSET = uint16(273); % NFFT + CP_LENGTH - 1

% Buffer sizes (power of 2)
BUFFER_BIT = uint16(11); % 2^11 = 2048 > SSB_LENGTH (1096) - Note: needs multiple turns
RX_BUFFER_SIZE = uint16(2^BUFFER_BIT);
FIFO_BIT = uint16(1); % 2^1 = 2
PEAK_FIFO_SIZE = uint16(2^FIFO_BIT);
% OUTPUT_BUFFER_SIZE = uint16(2048);

% Buffer masks for efficient addressing
RX_BUFFER_MASK = uint16(RX_BUFFER_SIZE - 1);
PEAK_FIFO_MASK = uint16(PEAK_FIFO_SIZE - 1);
% OUTPUT_BUFFER_MASK = uint16(2047); % OUTPUT_BUFFER_SIZE - 1

% State machine states
IDLE = uint8(0);
CHECK_EVENT = uint8(1);
WAITING_FOR_DATA = uint8(2);
PROCESSING_DATA = uint8(3);

% Data types
dataType = numerictype(1, 16, 15); % Q1.15 fixed-point

% Persistent variables (state memory)
persistent state
persistent sampleCounter
persistent rxBuffer_re rxBuffer_im
persistent rxWritePtr rxReadPtr
persistent peakFifo peakFifoWritePtr peakFifoReadPtr peakFifoCount
% persistent outputBuffer_re outputBuffer_im
% persistent outputWritePtr outputReadPtr outputCount
persistent extractStartIdx extractEndIdx extractSampleCount
persistent ssbCount
persistent processingPeakIdx

% Initialize persistent variables on first call
if isempty(state)
    % State machine initialization
    state = IDLE;
    sampleCounter = uint16(0);
    
    % Initialize buffers with proper fixed-point types
    rxBuffer_re = fi(zeros(RX_BUFFER_SIZE, 1), dataType);
    rxBuffer_im = fi(zeros(RX_BUFFER_SIZE, 1), dataType);
    rxWritePtr = uint16(0);
    rxReadPtr = uint16(0);
    
    % Peak FIFO initialization
    peakFifo = zeros(PEAK_FIFO_SIZE, 1, 'uint16');
    peakFifoWritePtr = uint16(0);
    peakFifoReadPtr = uint16(0);
    peakFifoCount = uint16(0);
    
    % Output buffer initialization
    % outputBuffer_re = fi(zeros(OUTPUT_BUFFER_SIZE, 1), dataType);
    % outputBuffer_im = fi(zeros(OUTPUT_BUFFER_SIZE, 1), dataType);
    % outputWritePtr = uint16(0);
    % outputReadPtr = uint16(0);
    % outputCount = uint16(0);
    
    % Processing variables
    extractStartIdx = uint16(0);
    extractEndIdx = uint16(0);
    extractSampleCount = uint16(0);
    ssbCount = uint16(0);
    processingPeakIdx = uint16(0);
end

% Initialize outputs
dataOut_re = fi(0, dataType);
dataOut_im = fi(0, dataType);
validOut = false;
ssbNumsOut = uint16(0);
ssbNumsValidOut = false;

% Buffer incoming data when valid
if validIn
    % Store received sample in circular buffer
    rxBuffer_re(rxWritePtr + 1) = dataIn_re;
    rxBuffer_im(rxWritePtr + 1) = dataIn_im;
    
    % Update write pointer with wrap-around
    if rxWritePtr == RX_BUFFER_MASK
        rxWritePtr = uint16(0);
    else
        rxWritePtr = rxWritePtr + uint16(1);
    end
    
    % Increment sample counter
    sampleCounter = sampleCounter + uint16(1);
end

% Buffer incoming peak events
if peakValid
    % Store peak in FIFO if not full
    if peakFifoCount < PEAK_FIFO_SIZE
        peakFifo(peakFifoWritePtr + 1) = peakIdx;
        
        % Update FIFO write pointer with wrap-around
        if peakFifoWritePtr == PEAK_FIFO_MASK
            peakFifoWritePtr = uint16(0);
        else
            peakFifoWritePtr = peakFifoWritePtr + uint16(1);
        end
        
        peakFifoCount = peakFifoCount + uint16(1);
        
        % Debug output - will be removed in final version
        %fprintf('DEBUG: Stored peak %d in FIFO, count now %d\n', peakIdx, peakFifoCount);
    end
end

% State machine processing
switch state
    case IDLE
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Transition to check for events
        state = CHECK_EVENT;
        
    case CHECK_EVENT
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Check if there are any peak events to process
        if peakFifoCount > uint16(0)
            % Read peak from FIFO
            processingPeakIdx = peakFifo(peakFifoReadPtr + 1);
            
            % Update FIFO read pointer with wrap-around
            if peakFifoReadPtr == PEAK_FIFO_MASK
                peakFifoReadPtr = uint16(0);
            else
                peakFifoReadPtr = peakFifoReadPtr + uint16(1);
            end
            
            peakFifoCount = peakFifoCount - uint16(1);
            
            % Calculate extraction indices (convert to 0-based)
            % extractStartIdx = (peakIdx) - PSS_OFFSET
            if processingPeakIdx >= PSS_OFFSET
                extractStartIdx = processingPeakIdx - PSS_OFFSET;
            else
                extractStartIdx = uint16(0); % Invalid case, will be handled
            end
            
            extractEndIdx = extractStartIdx + SSB_LENGTH;
            extractSampleCount = uint16(0);
            
            state = WAITING_FOR_DATA;
        else
            % No events to process, stay in CHECK_EVENT
            state = CHECK_EVENT;
        end
        
    case WAITING_FOR_DATA
        % Initialize all outputs for this state
        validOut = false;
        ssbNumsValidOut = false;
        
        % Check if enough data is available in the buffer
        % We need data up to extractEndIdx-1 (since extractEndIdx is exclusive)
        % Data is available if sampleCounter > extractEndIdx-1
        if sampleCounter >= extractEndIdx
            state = PROCESSING_DATA;
            bufferStartIdx = bitand(extractStartIdx - uint16(1), RX_BUFFER_MASK); 
            rxReadPtr = bufferStartIdx; % Set read pointer to start of extraction
        else
            % Not enough data available, stay in WAITING_FOR_DATA
            state = WAITING_FOR_DATA;
        end
        
    case PROCESSING_DATA
        % Initialize all outputs for this state
        ssbNumsValidOut = false;
        
        % Check if we have more samples to extract
        if extractSampleCount < SSB_LENGTH
            % Calculate buffer address with wrap-around
            if rxReadPtr == RX_BUFFER_MASK
                rxReadPtr = uint16(0);
            else
                rxReadPtr = rxReadPtr + uint16(1);
            end

            % Read sample from buffer
            sampleRe = rxBuffer_re(rxReadPtr + 1);
            sampleIm = rxBuffer_im(rxReadPtr + 1);

            % Output the sample
            dataOut_re = sampleRe;
            dataOut_im = sampleIm;
            validOut = true;
            
            % Increment sample count
            extractSampleCount = extractSampleCount + uint16(1);
            
            % Stay in PROCESSING_DATA state
            state = PROCESSING_DATA;
        else
            % Finished extracting this SSB symbol
            validOut = false;
            ssbCount = ssbCount + uint16(1);
            
            % Output SSB count
            ssbNumsOut = ssbCount;
            ssbNumsValidOut = true;
            
            % Return to check for more events
            state = CHECK_EVENT;
        end
        
    otherwise
        % Invalid state, return to IDLE
        validOut = false;
        ssbNumsValidOut = false;
        state = IDLE;
end

end
